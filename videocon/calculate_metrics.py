import torch
import csv
import pandas as pd


def compute_scores(output_csv):
    '''
    computes accuracy using the output file generated by owl-con / mplug-owl for all tests except ivat.
    For every video, the first row contains the score of the positive caption/video and the second row.
    contains the score of the negative caption/video.
    '''
    df = pd.read_csv(output_csv)
    e_scores = []
    for index, row in df.iterrows():
        e_scores.append(row['scores'])

    tot_cnt = 0
    cnt = 0
    for i in range(0,len(e_scores)-1,2):
        s1 = e_scores[i]
        s2 = e_scores[i+1]
        if s1 > s2:
            cnt += 1
        tot_cnt+= 1

    acc = round((cnt/tot_cnt * 100), 2)

    with open(output_csv, 'a') as f:
        writer = csv.writer(f)
        writer.writerow(["Total: {}".format(tot_cnt), "Correct: {}".format(cnt), "Acc: {}".format(acc)])



def compute_scores_wino(output_csv):
    '''
    computes accuracy using the output file generated by owl-con / mplug-owl for ivat.
    For every video, four scores are generated as four rows in the csv.
    '''

    df = pd.read_csv(output_csv)
    e_scores = []

    for index, row in df.iterrows():
        e_scores.append(row['scores'])

    tot_cnt = 0
    cnt = 0
    va_ca, va_cb, vb_ca, vb_cb = [], [], [], []
    for i in range(0,len(e_scores)-3,4):
        va_ca.append(e_scores[i]) 
        va_cb.append(e_scores[i+1]) 
        vb_ca.append(e_scores[i+2]) 
        vb_cb.append(e_scores[i+3]) 
        tot_cnt += 1
    
    va_ca, va_cb, vb_ca, vb_cb = torch.Tensor(va_ca), torch.Tensor(va_cb), torch.Tensor(vb_ca), torch.Tensor(vb_cb)

    w_s = wino(va_ca, va_cb, vb_ca, vb_cb)
    w_s = w_s / torch.tensor([tot_cnt, tot_cnt, tot_cnt, tot_cnt * 2, tot_cnt * 2])
    w_s = list(map(lambda x: round(x * 100, 2), w_s.tolist()))

    with open(output_csv, 'a') as f:
        writer = csv.writer(f)
        writer.writerow(["Total: {}".format(tot_cnt)])
        writer.writerow(["gt_cnt: {}".format(w_s[0]), "gv_cnt: {}".format(w_s[1])])
        writer.writerow(["group_cnt: {}".format(w_s[2])])
        writer.writerow(["ind_gt_cnt: {}".format(w_s[3]), "ind_gv_cnt: {}".format(w_s[4])])

def wino(va_ca_score,va_cb_score,vb_ca_score,vb_cb_score):
    gt_res = torch.logical_and((va_ca_score > vb_ca_score),(vb_cb_score > va_cb_score))
    gv_res = torch.logical_and((va_ca_score > va_cb_score),(vb_cb_score > vb_ca_score))
    group_res = torch.logical_and(gt_res,gv_res)

    gt_cnt = gt_res.sum()
    gv_cnt = gv_res.sum()
    group_cnt = group_res.sum()

    ind_gt_cnt = (va_ca_score > vb_ca_score).sum() + (vb_cb_score > va_cb_score).sum()
    ind_gv_cnt = (va_ca_score > va_cb_score).sum() + (vb_cb_score > vb_ca_score).sum()
    return torch.tensor([gt_cnt,gv_cnt,group_cnt,ind_gt_cnt,ind_gv_cnt])